snippet cf "cf start"
#include <bits/stdc++.h>

#define sz(a) ((int)((a).size()))
#define make_unique(x)            \\
  sort((x).begin(), (x).end()); \\
  (x).erase(unique((x).begin(), (x).end()), (x).end())

using namespace std;
// mt19937 rnd(239);
mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());

typedef long long ll;
typedef long double ld;

int solve() {
  $0
  return 0;
}

int32_t main() {
  ios::sync_with_stdio(0);
  cin.tie(0);
  int t = 1;
  $1cin >> t;
  while (t--) {
    solve();
#ifdef ONPC
    cout << "__________________________" << endl;
#endif
    }
#ifdef ONPC
    cerr << endl
         << "finished in " << clock() * 1.0 / CLOCKS_PER_SEC << " sec" << endl;
#endif
}
endsnippet

snippet for "for [0..end)"
for (int ${1:i} = 0; $1 < ${2:n}; ++$1) {
  $3
}$0
endsnippet

snippet fori "for [start..end]"
for (int ${1:i} = ${2:0}; $1 <= ${3:n}; ++$1) {
  $4
}$0
endsnippet

snippet rfor "for (n..0]"
for (int ${1:i} = ${2:n - 1}; $1 >= 0; --$1) {
  $3
}$0
endsnippet

snippet rfori "for [n..0]"
for (int ${1:i} = ${2:n}; $1 >= ${3:0}; --$1) {
  $4
}$0
endsnippet

snippet all "all wrapper" i
${1:arr}.begin(), $1.end()$0
endsnippet

snippet pb "push_back" i
push_back($1);$0
endsnippet

snippet gcd "gcd"
template<typename T>
T gcd(T a, T b) {
  while (a) {
    b %= a;
    swap(a, b);
  }
  return b;
}$0
endsnippet

snippet binpow "binpow"
template<typename T>
T binpow(T a, T b) {
  T ans = 1;
  while (b) {
    if (b & 1) {
      ans = 1LL * ans * a % MOD;
    }
    a = 1LL * a * a % MOD;
    b >>= 1;
  }
  return ans;
}$0
endsnippet

snippet lca "lca funcs"
vector<int> g[N];
int dep[N];
int anc[N][LG];

void dfs(int v, int par) {
  anc[v][0] = par;
  dep[v] = dep[par] + 1;
  for (int i = 1; i < LG; ++i) anc[v][i] = anc[anc[v][i - 1]][i - 1];
  for (auto u : g[v])
    if (u != par) dfs(u, v);
}

int lca(int a, int b) {
  if (dep[a] < dep[b]) swap(a, b);
  for (int i = LG - 1; i >= 0; --i)
    if (dep[anc[a][i]] >= dep[b]) a = anc[a][i];
  if (a == b) return a;
  for (int i = LG - 1; i >= 0; --i)
    if (anc[a][i] != anc[b][i]) a = anc[a][i], b = anc[b][i];
  return a;
}

int get_kth_anc(int v, int k) {
  for (int i = 0; i < LG; ++i)
    if (k & (1 << i)) v = anc[v][i];
  return v;
}

int get_dist(int a, int b) {
  int _lca = lca(a, b);
  return dep[a] + dep[b] - (dep[_lca] << 1);
}$0
endsnippet

snippet dsu "Disjoint Set Union"
struct Dsu {
  int n;
  vector<int> p, rk;

  Dsu(int _n): n(_n), p(_n), rk(_n) {
    std::iota(p.begin(), p.end(), 0);
  }

  int getp(int v) {
    return v == p[v] ? v : p[v] = getp(p[v]);
  }

  bool merge(int u, int v) {
    u = getp(u);
    v = getp(v);
    if (u == v) {
      return false;
    }
    if (rk[u] < rk[v]) {
      swap(u, v);
    }
    p[v] = u;
    if (rk[u] == rk[v]) {
      ++rk[u];
    }
    return true;
  }
}$0;
endsnippet

snippet segtree "Segment tree"
int N;

struct SegTree {
 private:
  struct Node {
    int l = -1, r = -1;
    int leftborder, rightborder;
    int value = 0;
    int add = 0;
  };

  const int Root = 0;
  vector<Node> Tree;

  void Set(int root, int l, int r, int pos, int val) {
    Tree[root].leftborder = l;
    Tree[root].rightborder = r;
    if (l == r) {
      Tree[root].value = val;
      return;
    }
    int m = (l + r) / 2;
    if (pos <= m) {
      if (Tree[root].l == -1) {
        Tree[root].l = Tree.size();
        Tree.emplace_back();
      }
      Set(Tree[root].l, l, m, pos, val);
    } else {
      if (Tree[root].r == -1) {
        Tree[root].r = Tree.size();
        Tree.emplace_back();
      }
      Set(Tree[root].r, m + 1, r, pos, val);
    }

    Tree[root].value = 0;
    if (Tree[root].l != -1) {
      Tree[root].value += Tree[Tree[root].l].value;
    }
    if (Tree[root].r != -1) {
      Tree[root].value += Tree[Tree[root].r].value;
    }
  }

  int Sum(int root, int l, int r, int ql, int qr) {
    if (ql == l && qr == r) {
      return Tree[root].value;
   }
    int m = (l + r) / 2;
    ll ans = 0;
    if (qr <= m && Tree[root].l != -1) {
      ans += Sum(Tree[root].l, l, m, ql, qr);
    } else if (ql >= m + 1 && Tree[root].r != -1) {
      ans += Sum(Tree[root].r, m + 1, r, ql, qr);
    } else {
      if (Tree[root].l != -1) {
        ans += Sum(Tree[root].l, l, m, ql, m);
      }
      if (Tree[root].r != -1) {
        ans += Sum(Tree[root].r, m + 1, r, m + 1, qr);
      }
    }
    return ans;
  }

  void Build(int root, int l, int r, vector<int> &a) {
    Tree[root].leftborder = l;
    Tree[root].rightborder = r;
    if (l == r) {
      Tree[root].value = a[l - 1];
      return;
    }
    if (Tree[root].l == -1) {
      Tree[root].l = Tree.size();
      Tree.emplace_back();
      Tree[root].r = Tree.size();
      Tree.emplace_back();
    }
    int m = (l + r) / 2;
    Build(Tree[root].l, l, m, a);
    Build(Tree[root].r, m + 1, r, a);
    Tree[root].value = Tree[Tree[root].l].value + Tree[Tree[root].r].value;
  }

 public:
  SegTree() {
    Tree.reserve(2 * N);
    Tree.emplace_back();
  }

  void Build(vector<int> &a) { Build(Root, 1, N, a); }
  void Set(int pos, int val) { Set(Root, 1, N, pos, val); }
  int Sum(int ql, int qr) { return Sum(Root, 1, N, ql, qr); }
};
endsnippet

snippet sparse "Sparse table"
struct SparseTable {
 private:
  vector<vector<int>> table;
  int N;
  int logn;

 public:
  SparseTable(vector<int> &a) {
    N = int(a.size());
    logn = 0;
    while (1 << logn <= N) {
      logn++;
    }
    table = vector<vector<int>>(logn, vector<int>(N));
    for (int i = 0; i < N; i++) {
      table[0][i] = a[i];
    }
    for (int l = 1; l < logn; ++l) {
      for (int i = 0; i + (1 << (l - 1)) < N; ++i) {
        table[l][i] = min(table[l - 1][i], table[l - 1][i + (1 << (l - 1))]);
      }
    }
  }

  int rmq(int l, int r) {
    int t = __lg(r - l + 1);
    return min(table[t][l], table[t][r - (1 << t) + 1]);
  }
};
endsnippet

snippet mat "Matix structure with binary exp"

struct Mat {

  int n, m;
  vector<vector<int>> value;

  Mat(){};
  Mat(int _n, int _m) {
    n = _n;
    m = _m;
    value.assign(n, vector<int>(m, 0));
  }
  Mat(int _n, int _m, int _val) {
    n = _n;
    m = _m;
    value.assign(n, vector<int>(m, _val));
  }

  inline void fill1() {
    assert(n == m);
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < n; j++) {
        value[i][j] = (i == j);
      }
    }
  }

  inline Mat operator*(const Mat &b) {
    assert(m == b.n);
    Mat ans = Mat(n, b.m);
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < b.m; j++) {
        for (int k = 0; k < m; k++) {
          ans.value[i][j] =
              (ans.value[i][j] + 1LL * value[i][k] * b.value[k][j] % MOD) % MOD;
        }
      }
    }
    return ans;
  }

  inline Mat pow(long long k) {
    assert(n == m);
    Mat ans(n, n);
    ans.fill1();
    Mat tmp = *this;
    while (k) {
      if (k & 1) {
        ans = ans * tmp;
      }
      tmp = tmp * tmp;
      k >>= 1;
    }
    return ans;
  }
};

endsnippet

snippet scc "Find strong connected components"
const int N = 3e5 + 9;

// given a directed graph return the minimum number of edges to be added so that
// the whole graph  become an SCC
bool used[N];
vector<int> g[N], r[N], G[N], order;  // G is the condensed graph
void dfs1(int u) {
  used[u] = true;
  for (auto v : g[u])
    if (!used[v]) dfs1(v);
  order.push_back(u);
}

vector<int> component;
void dfs2(int u) {
  component.push_back(u);
  used[u] = 1;
  for (auto v : r[u])
    if (!used[v]) dfs2(v);
}

int scc_num[N], in[N], out[N];
int solve() {
  int n, m;
  cin >> n >> m;
  for (int i = 1; i <= m; i++) {
    int u, v;
    cin >> u >> v;
    g[u].push_back(v);
    r[v].push_back(u);
  }
  for (int i = 1; i <= n; i++)
    if (!used[i]) dfs1(i);
  reverse(order.begin(), order.end());
  memset(used, 0, sizeof used);
  int scc = 0;
  for (auto u : order) {
    if (!used[u]) {
      component.clear();
      dfs2(u);
      scc++;
      for (auto x : component) scc_num[x] = scc;
    }
  }
  for (int u = 1; u <= n; u++) {
    for (auto v : g[u]) {
      if (scc_num[u] != scc_num[v]) {
        in[scc_num[v]]++, out[scc_num[u]]++;
        G[scc_num[u]].push_back(scc_num[v]);
      }
    }
  }
  int needed_in = 0, needed_out = 0;
  for (int i = 1; i <= scc; i++) {
    if (!in[i]) needed_in++;
    if (!out[i]) needed_out++;
  }
  int ans = max(needed_in, needed_out);
  if (scc == 1) ans = 0;
  cout << ans << '\n';
  return 0;
}
endsnippet

snippet bridge "find bridges"
const int N = 2e4 + 1;
int timer;
bool used[N];
vector<int> g[N];
int timer, tin[N], up[N], down[N], dp[N];

map<pair<int, int>, int> ind;
vector<int> ans;

void is_bridge(int v, int to) {
  if (v > to) swap(v, to);
  if (ind.count({v, to}) && ind[{v, to}] != -1) ans.push_back(ind[{v, to}]);
}

void dfs(int v, int p = -1) {
  used[v] = true;
  tin[v] = timer++;
  for (auto to : g[v]) {
    if (to == p) continue;
    if (!used[to]) {
      dfs(to, v);
      dp[v] += dp[to];
    } else {
      if (tin[to] < tin[v]) {
        up[v]++;
        down[to]++;
      }
    }
  }
  dp[v] += up[v] - down[v];
  if (dp[v] == 0) is_bridge(p, v);
}

int solve() {
  int n, m;
  cin >> n >> m;
  fill(tin, tin + N, INT_MAX);
  timer = 0;
  for (int i = 0; i < m; ++i) {
    int u, v;
    cin >> u >> v;
    if (u == v) continue;
    if (u > v) swap(u, v);
    if (ind.count({u, v}))
      ind[{u, v}] = -1;
    else {
      ind[{u, v}] = i + 1;
      g[u].push_back(v);
      g[v].push_back(u);
    }
  }
  for (int i = 1; i <= n; ++i)
    if (!used[i]) dfs(i);
  sort(ans.begin(), ans.end());
  cout << sz(ans) << '\n';
  for (auto el : ans) cout << el << ' ';
  return 0;
}
endsnippet
snippet dij "Dijkstra"
#define int long long

const ll N = 2e5 + 10;
const ll MAX = 1e18;

int n, m;
vector<int> d, p;
vector<vector<pair<int, int>>> gr;

void dijkstra(int st) {
  p.assign(n + 1, -1);
  d.assign(n + 1, MAX);

  priority_queue<pair<int, int>> q;

  d[st] = 0;
  p[st] = st;
  q.push({0, st});
  while (!q.empty()) {
    int v = q.top().second, dist = -q.top().first;
    q.pop();
    if (dist > d[v]) continue;
    for (auto &to : gr[v]) {
      if (dist + to.second < d[to.first]) {
        d[to.first] = dist + to.second;
        p[to.first] = v;
        q.push({-d[to.first], to.first});
      }
    }
  }
}

void printPath(int finish) {
  int cur = finish;
  vector<int> ans;
  while (p[cur] != cur) {
    ans.push_back(cur);
    cur = p[cur];
  }
  ans.push_back(cur);

  for (int i = sz(ans) - 1; i >= 0; --i) {
    cout << ans[i] << " ";
  }
  cout << endl;
}

void solve() {
  cin >> n >> m;
  gr.assign(n + 1, vector<pair<int, int>>());

  for (int i = 0; i < m; ++i) {
    int u, v, w;
    cin >> u >> v >> w;
    gr[u].emplace_back(v, w);
    gr[v].emplace_back(u, w);
  }
  dijkstra(1);

  if (d[n] == MAX) {
    cout << -1 << '\n';
  } else {
    printPath(n);
  }
}
endsnippet
snippet spfa "Shortest Path Faster"
vector<vector<pair<int, int>>> g;
vector<ll> d;

vector<bool> inQueue;
void spfa(int s, int n) {
  d[s] = 0;
  inQueue.assign(n + 1, false);
  queue<int> q;
  q.push(s);
  inQueue[s] = true;
  while (!q.empty()) {
    int v = q.front();
    q.pop();
    inQueue[v] = false;
    for (auto &[to, w] : g[v]) {
      if (d[v] + w < d[to]) {
        d[to] = d[v] + w;
        if (!inQueue[to]) {
          inQueue[to] = true;
          q.push(to);
        }
      }
    }
  }
}

// vector<bool> used;
// bool spfa_with_cycles(int u) {
//   used[u] = 1;
//   for (auto e : g[u]) {
//     int w = e.second, v = e.first;
//     if (d[u] + w < d[v]) {
//       if (used[v]) return 0;
//       d[v] = d[u] + w;
//       if (!spfa_with_cycles(v)) return 0;
//     }
//   }
//   used[u] = 0;
//   return 1;
// }
//
// int32_t main() {
//   ios_base::sync_with_stdio(0);
//   cin.tie(0);
//
//   int t;
//   cin >> t;
//   while (t--) {
//     used.assign(n + 1, false);
//     int n, m;
//     cin >> n >> m;
//     for (int i = 0; i <= n; i++) g[i].clear();
//     int ans = 1e9;
//     for (int i = 1; i <= m; i++) {
//       int u, v, w;
//       cin >> u >> v >> w;
//       g[u].push_back({v, w});
//       ans = min(ans, w);
//     }
//     if (ans >= 0) {
//       cout << ans << '\n';
//       continue;
//     }
//     for (int i = 1; i <= n; i++) g[0].emplace_back(i, 0);
//     for (int i = 0; i <= n; i++) d[i] = 1e9, used[i] = 0;
//     int s = 0;
//     d[s] = 0;
//     if (spfa(s) == 0)
//       cout << "-inf\n";  // negative cycle
//     else {
//       long long ans = d[1];
//       for (int i = 1; i <= n; i++) ans = min(ans, d[i]);
//       cout << ans << '\n';
//     }
//   }
//   return 0;
// }
// // https://codeforces.com/gym/101498/problem/L

int solve() {
  int n, m;
  cin >> n >> m;
  g.assign(n + 1, vector<pair<int, int>>());
  d.assign(n + 1, INT_MAX);
  d[1] = 0;
  for (int i = 0; i < m; ++i) {
    int u, v, w;
    cin >> u >> v >> w;
    g[u].emplace_back(v, w);
  }
  spfa(1, n);
  for (int i = 1; i <= n; ++i) {
    cout << d[i] << ' ';
  }
  return 0;
}
endsnippet
